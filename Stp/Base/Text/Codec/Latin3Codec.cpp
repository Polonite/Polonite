// Copyright 2017 Polonite Authors. All rights reserved.
// Distributed under MIT license that can be found in the LICENSE file.

#include "Base/Text/TextEncoding.h"

#include "Base/Text/Utf.h"

namespace stp {

namespace {

// 0xA0..0xFF
const char16_t Latin3ToUnicode[96] = {
  0x00A0, 0x0126, 0x02D8, 0x00A3, 0x00A4, 0x0000, 0x0124, 0x00A7,
  0x00A8, 0x0130, 0x015E, 0x011E, 0x0134, 0x00AD, 0x0000, 0x017B,
  0x00B0, 0x0127, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x0125, 0x00B7,
  0x00B8, 0x0131, 0x015F, 0x011F, 0x0135, 0x00BD, 0x0000, 0x017C,
  0x00C0, 0x00C1, 0x00C2, 0x0000, 0x00C4, 0x010A, 0x0108, 0x00C7,
  0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
  0x0000, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x0120, 0x00D6, 0x00D7,
  0x011C, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x016C, 0x015C, 0x00DF,
  0x00E0, 0x00E1, 0x00E2, 0x0000, 0x00E4, 0x010B, 0x0109, 0x00E7,
  0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
  0x0000, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x0121, 0x00F6, 0x00F7,
  0x011D, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x016D, 0x015D, 0x02D9,
};

TextConversionResult Decode(
    TextConversionContext* context, BufferSpan input, MutableStringSpan output, bool flush) {
  auto* input_data = static_cast<const byte_t*>(input.data());
  int num_read = 0;
  int num_wrote = 0;
  bool did_fallback = false;

  while (num_read < input.size() && num_wrote < output.size()) {
    byte_t b = input_data[num_read];
    if (b < 0x80) {
      output[num_wrote++] = static_cast<char>(b);
    } else {
      char16_t c = b < 0xA0 ? static_cast<char16_t>(b) : Latin3ToUnicode[b - 0xA0];
      if (!c) {
        c = unicode::ReplacementCodepoint;
        did_fallback = true;
      }
      int encoded = TryEncodeUtf(output.GetSlice(num_wrote), c);
      if (encoded == 0)
        break;
      num_wrote += encoded;
    }
    ++num_read;
  }
  return TextConversionResult(num_read, num_wrote, did_fallback);
}

TextConversionResult Decode16(
    TextConversionContext* context, BufferSpan input, MutableString16Span output, bool flush) {
  auto* input_data = static_cast<const byte_t*>(input.data());
  int num_read = 0;
  int num_wrote = 0;
  bool did_fallback = false;

  while (num_read < input.size() && num_wrote < output.size()) {
    byte_t b = input_data[num_read];
    char16_t c;
    if (b < 0xA0) {
      c = static_cast<char16_t>(b);
    } else {
      c = Latin3ToUnicode[b - 0xA0];
      if (!c) {
        c = unicode::ReplacementCodepoint;
        did_fallback = true;
      }
    }
    output[num_wrote++] = c;
    ++num_read;
  }
  return TextConversionResult(num_read, num_wrote, did_fallback);
}

// 0x00A0..0x00FF
const byte_t Latin3Page00[96] = {
  0xA0, 0x00, 0x00, 0xA3, 0xA4, 0x00, 0x00, 0xA7,
  0xA8, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x00, 0x00,
  0xB0, 0x00, 0xB2, 0xB3, 0xB4, 0xB5, 0x00, 0xB7,
  0xB8, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x00, 0x00,
  0xC0, 0xC1, 0xC2, 0x00, 0xC4, 0x00, 0x00, 0xC7,
  0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
  0x00, 0xD1, 0xD2, 0xD3, 0xD4, 0x00, 0xD6, 0xD7,
  0x00, 0xD9, 0xDA, 0xDB, 0xDC, 0x00, 0x00, 0xDF,
  0xE0, 0xE1, 0xE2, 0x00, 0xE4, 0x00, 0x00, 0xE7,
  0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
  0x00, 0xF1, 0xF2, 0xF3, 0xF4, 0x00, 0xF6, 0xF7,
  0x00, 0xF9, 0xFA, 0xFB, 0xFC, 0x00, 0x00, 0x00,
};
// 0x0108..0x017F
const byte_t Latin3Page01[120] = {
  0xC6, 0xE6, 0xC5, 0xE5, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xD8, 0xF8, 0xAB, 0xBB,
  0xD5, 0xF5, 0x00, 0x00, 0xA6, 0xB6, 0xA1, 0xB1,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xA9, 0xB9, 0x00, 0x00, 0xAC, 0xBC, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xDE, 0xFE, 0xAA, 0xBA,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xDD, 0xFD, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xAF, 0xBF, 0x00, 0x00, 0x00,
};
// 0x02D8..0x02DF
const byte_t Latin3Page02[8] = {
  0xA2, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

byte_t EncodeExtra(char32_t c) {
  ASSERT(c >= 0xA0);

  if (c < 0x0100)
    return Latin3Page00[c - 0x00A0];
  if (0x0108 <= c && c < 0x0180)
    return Latin3Page01[c - 0x0108];
  if (0x02D8 <= c && c < 0x02E0)
    return Latin3Page02[c - 0x02D8];

  return 0;
}

template<typename T>
inline TextConversionResult EncodeTmpl(
    TextConversionContext* context, Span<T> input, MutableBufferSpan output) {
  auto* iptr = begin(input);
  auto* const iptr_end = end(input);
  auto* output_data = static_cast<byte_t*>(output.data());
  int num_wrote = 0;
  bool did_fallback = false;

  while (iptr < iptr_end) {
    char32_t c = DecodeUtf(iptr, iptr_end);
    if (c < 0xA0) {
      output_data[num_wrote++] = static_cast<byte_t>(c);
    } else  {
      byte_t b = EncodeExtra(c);
      if (b == 0) {
        b = '?';
        did_fallback = true;
      }
      output_data[num_wrote++] = b;
    }
  }
  return TextConversionResult(iptr - input.data(), num_wrote, did_fallback);
}

TextConversionResult Encode(
    TextConversionContext* context, StringSpan input, MutableBufferSpan output) {
  return EncodeTmpl(context, input, output);
}
TextConversionResult Encode16(
    TextConversionContext* context, String16Span input, MutableBufferSpan output) {
  return EncodeTmpl(context, input, output);
}

constexpr StringSpan Aliases[] = {
  "iso-ir-109",
  "latin3",
  "L3",
};

constexpr TextCodecVtable Vtable = {
  Decode, Decode16,
  Encode, Encode16,
};

constexpr auto Build() {
  auto builder = BuildTextCodec("ISO-8859-3", Vtable);
  builder.SetAliases(Aliases);
  builder.SetIanaCodepage(6);
  builder.SetWindowsCodepage(28593);
  return builder;
}

} // namespace

namespace detail {
constexpr const TextCodec Latin3Codec = Build();
}

} // namespace stp
